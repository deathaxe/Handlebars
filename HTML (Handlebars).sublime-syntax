%YAML 1.2
---
name: HTML Handlebars
scope: text.html.handlebars
version: 2

extends: Packages/HTML/HTML.sublime-syntax

file_extensions:
  - handlebars
  - handlebars.html
  - hbs

first_line_match: (?i)<(!DOCTYPE\s*)?html

variables:
  ANY_CHAR: .*?

  TAG_BEGIN:     ({{(~?){?) # constant.character.control.whitespace ?
  TAG_END:       (}?(~?)}})(?!})
  TAG_END_PAREN: (?:(\))|(}?(~?)}})(?!}))
  TAG_END_CHAR: \s~}
  NOT_TAG_END:  '[^{{TAG_END_CHAR}}]+(?:\s+[^{{TAG_END_CHAR}}]+)*'
  EMPTY_LINE:   ^\s*$
  PATH_START:   (?:\.\.?\s*\/\s*)*
  PATH_NAME:    (?:[\w_-][\w\._-]*)
  PATH:         (?:{{PATH_START}}{{PATH_NAME}}|\.)(?=[{{TAG_END_CHAR}}])
  PATH_QUOTED:  (?:[^\s'"]|\'")(?=[\s'"~}])
  PATH_QUOTED_SINGLE:  (')((?:\\'|[^'])+)(')
  PATH_QUOTED_DOUBLE:  (")((?:\\"|[^"])+)(")
  PATH_DOTTED_OR_SLASHED: '{{IDENTIFIER}}(?:\ *(?:\.(?:\[{{ANY_CHAR}}\]|''[^'']*''|"[^"]*"|{{IDENTIFIER}})|\/ *{{IDENTIFIER}}))*'
  SEPARATOR:    '[./){{TAG_END_CHAR}}]' # close paren only occurs within subexpression
  TOKEN:        '[^{{TAG_END_CHAR}}]'
  TOKEN_QUOTED: (['"])({{ANY_CHAR}})(\2)
  IDENTIFIER:                '[^\s!"#%&''()*+,./;<=>@\[\\\]^`{|}~]+'
  IDENTIFIER_CHAR:           '[^\s!"#%&''()*+,./;<=>@\[\\\]^`{|}~]' # maybe name sets `*_SET`
  NON_IDENTIFIER_CHAR:        '[\s!"#%&''()*+,./;<=>@\[\\\]^`{|}~]'
  NOT_IDENTIFIER_NOT_SPACE:     '[!"#%&''()*+,./;<=>@\[\\\]^`{|}~]'
  NOT_IDENTIFIER_NOT_SEPARATOR: '[!"#%&''()*+,;<=>@\[\\\]^`{|}~]'
  NUMBER:       ([+-]?\d+(?:\.\d+)?)
  BOOLEAN:      (?i:(true)|(false))

  LOOKAHEAD:         '[~}\s)/.|=]'
  LITERAL_LOOKAHEAD: '[~}\s)]'

contexts:

###[ CUSTOM HTML ]############################################################

  prototype:
    - include: handlebars-embedded

  cdata-content:
    - meta_prepend: true
    - meta_include_prototype: false
    - include: handlebars-interpolations

  script-javascript-content:
    - meta_include_prototype: false
    - match: \s*((<!\[)(CDATA)(\[))
      captures:
        1: meta.tag.sgml.cdata.html
        2: punctuation.definition.tag.begin.html
        3: keyword.declaration.cdata.html
        4: punctuation.definition.tag.begin.html
      pop: 1  # make sure to match only once
      embed: scope:source.js.handlebars
      embed_scope: meta.tag.sgml.cdata.html source.js.embedded.html
      escape: \]\]>
      escape_captures:
        0: meta.tag.sgml.cdata.html punctuation.definition.tag.end.html
    - match: '{{script_content_begin}}'
      captures:
        1: comment.block.html punctuation.definition.comment.begin.html
      pop: 1  # make sure to match only once
      embed: scope:source.js.handlebars
      embed_scope: source.js.embedded.html
      escape: '{{script_content_end}}'
      escape_captures:
        1: source.js.embedded.html
        2: comment.block.html punctuation.definition.comment.end.html
        3: source.js.embedded.html
        4: comment.block.html punctuation.definition.comment.end.html

  style-css-content:
    - meta_include_prototype: false
    - match: \s*((<!\[)(CDATA)(\[))
      captures:
        1: meta.tag.sgml.cdata.html
        2: punctuation.definition.tag.begin.html
        3: keyword.declaration.cdata.html
        4: punctuation.definition.tag.begin.html
      pop: 1  # make sure to match only once
      embed: scope:source.css.handlebars
      embed_scope: meta.tag.sgml.cdata.html source.css.embedded.html
      escape: \]\]>
      escape_captures:
        0: meta.tag.sgml.cdata.html punctuation.definition.tag.end.html
    - match: '{{style_content_begin}}'
      captures:
        1: comment.block.html punctuation.definition.comment.begin.html
      pop: 1  # make sure to match only once
      embed: scope:source.css.handlebars
      embed_scope: source.css.embedded.html
      escape: '{{style_content_end}}'
      escape_captures:
        1: source.css.embedded.html
        2: comment.block.html punctuation.definition.comment.end.html
        3: source.css.embedded.html
        4: comment.block.html punctuation.definition.comment.end.html

  tag-event-attribute-value:
    - match: \"
      scope:
        meta.string.html string.quoted.double.html
        punctuation.definition.string.begin.html
      embed: scope:source.js.handlebars
      embed_scope:
        meta.string.html meta.interpolation.html
        source.js.embedded.html
      escape: \"
      escape_captures:
        0: meta.string.html string.quoted.double.html
           punctuation.definition.string.end.html
    - match: \'
      scope:
        meta.string.html string.quoted.single.html
        punctuation.definition.string.begin.html
      embed: scope:source.js.handlebars
      embed_scope:
        meta.string.html meta.interpolation.html
        source.js.embedded.html
      escape: \'
      escape_captures:
        0: meta.string.html string.quoted.single.html
           punctuation.definition.string.end.html
    - include: else-pop

  tag-style-attribute-value:
    - match: \"
      scope:
        meta.string.html string.quoted.double.html
        punctuation.definition.string.begin.html
      embed: scope:source.css.handlebars#rule-list-body
      embed_scope:
        meta.string.html meta.interpolation.html
        source.css.embedded.html
      escape: \"
      escape_captures:
        0: meta.string.html string.quoted.double.html
           punctuation.definition.string.end.html
    - match: \'
      scope:
        meta.string.html string.quoted.single.html
        punctuation.definition.string.begin.html
      embed: scope:source.css.handlebars#rule-list-body
      embed_scope:
        meta.string.html meta.interpolation.html
        source.css.embedded.html
      escape: \'
      escape_captures:
        0: meta.string.html string.quoted.single.html
           punctuation.definition.string.end.html
    - include: else-pop

  tag-attribute-value-content:
    - meta_prepend: true
    - include: handlebars-interpolations

  strings-common-content:
    - meta_prepend: true
    - include: handlebars-interpolations

###[ HANDLEBARS INTERPOLATIONS ]##################################################

  handlebars-interpolations:
    - match: (?={{)
      push: handlebars-interpolation-content

  handlebars-interpolation-content:
    - meta_include_prototype: false
    - clear_scopes: 1
    - meta_scope: meta.interpolation.handlebars
    - include: handlebars-embedded
    - include: immediately-pop

  handlebars-embedded:
    - include: handlebars-comments
    - include: handlebars-escaped-stache
    - include: handlebars-tag-block-raw
    #- include: handlebars-tag-raw
    - include: handlebars-tag-unescaped
    - include: handlebars-tag-partially-one-line
    - include: handlebars-tag-one-line
    - include: handlebars-tag

###[ HANDLEBARS COMMENTS ]########################################################

  handlebars-comments:
    - match: '{{~?!--'
      scope: punctuation.definition.comment.block.explicit.begin.handlebars
      push: handlebars-comment-explicit-content
    - match: '{{~?!'
      scope: punctuation.definition.comment.block.begin.handlebars
      push: handlebars-comment-content

  handlebars-comment-explicit-content:
    - meta_scope: comment.block.explicit.handlebars
    - match: '--~?}}'
      scope: punctuation.definition.comment.block.explicit.end.handlebars
      pop: true
    - include: handlebars-comment-annotation

  handlebars-comment-content:
    - meta_scope: comment.block.handlebars
    - match: '~?}}'
      scope: punctuation.definition.comment.block.end.handlebars
      pop: true
    - include: handlebars-comment-annotation

  handlebars-comment-annotation:
    - match: (@)\w+\b
      scope: variable.annotation.handlebars
      captures:
        1: punctuation.definition.annotation.handlebars

  handlebars-escaped-stache:
    - match: \\{
      scope: constant.character.escape.handlebars

###[ HANDLEBARS TAGS ]############################################################

  handlebars-tag-raw:
    - match: (?={{{{/?)
      push:
      - meta_scope: meta.tag.template.raw.handlebars

      - match: ({{{{)(/)?
        captures:
          1: punctuation.definition.tag.template.begin.handlebars
          2: constant.character.block.close.handlebars
        push:
        - include: -tag-guts-

      - match: (?<=}}}})
        pop: true

  handlebars-tag-unescaped:
    - match: (?={{~?{[^{])
      push:
      - meta_scope: meta.tag.template.unescaped.handlebars

      - match: (?:{{TAG_BEGIN}})
        captures:
          1: punctuation.definition.tag.template.begin.handlebars
        push:
        - include: -tag-guts-

      - match: (?<=}}})
        pop: true

      - match: (?<=}~}})
        pop: true

  handlebars-tag:
    - match: (?={{[^{])
      push:
      - meta_scope: meta.tag.template.handlebars

      - include: -tag-end-
      - include: -after-tag-end-pop-

      - include: -tag-block-open-
      - include: -tag-block-close-

      - match: (?:{{TAG_BEGIN}})
        captures:
          1: punctuation.definition.tag.template.begin.handlebars
        push:
        - include: -else- # `else` only works between double mustaches
        - include: -tag-guts-


  # Match tags that have the open tag and two identifiers (indicating that the tag is not just a
  # path, but actually a helper).
  handlebars-tag-partially-one-line:
    - match: (?={{TAG_BEGIN}} *(?!this|else){{PATH_DOTTED_OR_SLASHED}}[^~}]*$)
      push:
      - meta_scope: meta.tag.template.partially-one-line.handlebars

      - include: -tag-end-
      - include: -after-tag-end-pop-

      - match: (?:{{TAG_BEGIN}}) *({{PATH_DOTTED_OR_SLASHED}}) # TODO: match individual parts
        captures:
          1: punctuation.definition.tag.template.begin.handlebars
          3: entity.name.function.helper # variable.function
        push:
        - include: -tag-guts-

      - match: (?:{{TAG_BEGIN}})
        captures:
          1: punctuation.definition.tag.template.begin.handlebars
        push:
        - include: -else-
        - include: -tag-guts-

  handlebars-tag-one-line:
    # - match: (?={{TAG_BEGIN}} *(?!this|else){{PATH_DOTTED_OR_SLASHED}} +[^./{{TAG_END_CHAR}}]{{ANY_CHAR}}{{TAG_END}})
    # - match: (?={{TAG_BEGIN}} *(?!this|else){{PATH_DOTTED_OR_SLASHED}} +(\.(?=[ ~}])|[^./ ~}]){{ANY_CHAR}}{{TAG_END}})
    - match: (?={{TAG_BEGIN}} *(?!this|else){{PATH_DOTTED_OR_SLASHED}} +(?!\/ *.|\.[^. ~}]|[ ~}]){{ANY_CHAR}}{{TAG_END}})
      push:
      - meta_scope: meta.tag.template.singleline.handlebars

      - include: -tag-end-
      - include: -after-tag-end-pop-

      - match: (?:{{TAG_BEGIN}}) *({{PATH_DOTTED_OR_SLASHED}}) # +([^ ~}]{{ANY_CHAR}}){{TAG_END}}
        captures:
          1: punctuation.definition.tag.template.begin.handlebars
          3: entity.name.function.helper # variable.function
        push:
        - include: -tag-guts-

      # - match: (?:{{TAG_BEGIN}}) *({{PATH_DOTTED_OR_SLASHED}})(?= +[^ ~}]) # TODO: match individual parts
      #   captures:
      #     #1: punctuation.definition.tag.template.begin
      #     3: entity.name.function.helper # variable.function
      #   push:
      #   - include: -tag-guts-

      # - match: (?:{{TAG_BEGIN}})
      #   # captures:
      #   #   1: punctuation.definition.tag.template.begin
      #   push:
      #   - include: -else-
      #   - include: -tag-guts-



  -tag-guts-:
    - include: -tag-end-
    - include: -subexpression-end-
    - include: -subexpression-
    - include: -named-parameter-
    - include: -key-value-
    - include: -string-quoted-double-
    - include: -string-quoted-single-
    - include: -data-var-
    - include: -path-
    - include: -path-id-

  handlebars-tag-block-raw:
    # Unmatched Block Close Tag
    - match: ({{{{~?/)
      scope: invalid.illegal.missing-raw-block-open-tag.handlebars

    # Before Block Open Tag
    - match: (?={{{{~?[^/])
      push:

      # Block Open Tag - Begin
      - match: ({{{{(~?))(?=[^/])
        scope: punctuation.definition.tag.template.begin.handlebars
        push:
        - meta_scope: meta.tag.template.handlebars

        # Pop Before Tag End
        - match: (?=\s*~?}}}})
          pop: true

        # Invalid Chars
        - match: ({{NOT_IDENTIFIER_NOT_SPACE}}+)
          scope: invalid.illegal.expected-identifier.handlebars
          pop: true

        # Helper Name
        - match: \s*({{IDENTIFIER}}(?:\s*[./]{{IDENTIFIER}})*) # TODO: match individual parts
          scope: entity.name.function.helper # variable.function.handlebars
          push:
          # Pop Before Tag End
          - match: (?=\s*~?}}}})
            pop: true
          # Pop Before Invalid Chars
          - match: (?=[!#%&)*+,/;<=>\[\\\]^`{}~])
            pop: true
          - include: -tag-block-guts-

        # Pop Before Invalid Char
        - match: (?=[^{{TAG_END_CHAR}}])
          pop: true

      # Block Open Tag - End
      - match: \s*(~?)(}}}})
        scope: meta.tag.template.handlebars
        captures:
          2: punctuation.definition.tag.template.end.handlebars
        set:

        # Block Close Tag - Begin
        - match: ({{{{(~?))(\/)
          captures:
            1: punctuation.definition.tag.template.begin.handlebars
            3: constant.character.block.close.handlebars
          set:
          - meta_scope: meta.tag.template.block.raw.handlebars

          # `raw` Helper
          - match: \braw(?=[{{TAG_END_CHAR}}])
            scope: entity.name.function.helper.builtin.handlebars
            push:
            # Pop Before Tag End
            - match: (?=\s*~?}}}})
              pop: true
            # Pop Before Bad Tag End (Wrong # of Mustaches)
            - match: (?=\s*~?}+)
              pop: true
            # Invalid Other Chars
            - match: \s*({{ANY_CHAR}})(?=\s*~?}}}})
              captures:
                1: invalid.illegal.expected-tag-end.handlebars
              pop: true

          # Other Helper
          - match: (?:{{PATH_DOTTED_OR_SLASHED}})
            scope: entity.name.function.helper.handlebars
            push:
            # Pop Before Tag End
            - match: (?=\s*~?}}}})
              pop: true
            # Pop Before Bad Tag End (Wrong # of Mustaches)
            - match: (?=\s*~?}+)
              pop: true
            # Invalid Other Chars
            - match: \s*({{ANY_CHAR}})(?=\s*~?}}}})
              captures:
                1: invalid.illegal.expected-tag-end.handlebars
              pop: true

          # Block Close Tag - End
          - match: \s*(~?)(}}}})
            captures:
              2: punctuation.definition.tag.template.end.handlebars
            pop: true

          # Bad Tag End (Wrong # of Mustaches)
          - match: \s*(~?}+)
            captures:
              1: invalid.illegal.expected-four-mustaches.handlebars
            pop: true

      # Pop Before Invalid Char
      - match: (?=[^\s~{}])
        pop: true



  -tag-block-open-:
    - match: (?:{{TAG_BEGIN}})(\^)
      captures:
        1: punctuation.definition.tag.template.begin.handlebars
        3: constant.character.block.inverted.open.handlebars
      push:
      #- meta_scope: meta.tag.template.block.handlebars
      - match: ({{IDENTIFIER}}(?:\s*[./]{{IDENTIFIER}})*) # TODO: match individual parts
        scope: entity.name.function.helper # variable.function.handlebars
        set:
        - include: -tag-block-guts-

      - include: -tag-end-

    - match: (?:{{TAG_BEGIN}})(>)
      captures:
        1: punctuation.definition.tag.template.begin.handlebars
        3: constant.character.partial.handlebars
      push:
      #- meta_scope: meta.tag.template.block.handlebars
      - include: -subexpression-
      - include: -data-var-
      - match: ({{IDENTIFIER}}(?:\s*[./]{{IDENTIFIER}})*) # TODO: match individual parts
        scope: entity.name.function.helper # variable.function.handlebars
        set:
        - include: -tag-block-guts-

      - include: -tag-end-

    - match: (?:{{TAG_BEGIN}})(#)(>)
      captures:
        1: punctuation.definition.tag.template.begin.handlebars
        3: constant.character.block.open.handlebars
        4: constant.character.partial.handlebars
      push:
      #- meta_scope: meta.tag.template.block.handlebars
      - include: -subexpression-
      - include: -data-var-
      - match: ({{IDENTIFIER}}(?:\s*[./]{{IDENTIFIER}})*) # TODO: match individual parts
        scope: entity.name.function.helper # variable.function.handlebars
        set:
        - include: -tag-block-guts-

      - include: -tag-end-

    - match: (?:{{TAG_BEGIN}})(#)(\*)
      captures:
        1: punctuation.definition.tag.template.begin.handlebars
        3: constant.character.block.open.handlebars
        4: constant.character.inline-partial.handlebars
      push:
      #- meta_scope: meta.tag.template.block.handlebars
      - match: ({{IDENTIFIER}}(?:\s*[./]{{IDENTIFIER}})*) # TODO: match individual parts
        scope: entity.name.function.helper # variable.function.handlebars
        set:
        - include: -tag-block-guts-

      - include: -tag-end-

    - match: (?:{{TAG_BEGIN}})(#)
      captures:
        1: punctuation.definition.tag.template.begin.handlebars
        3: constant.character.block.open.handlebars
      push:
      #- meta_scope: meta.tag.template.block.handlebars
      - match: \b(?:(if)|(unless))(?=\s)
        captures:
          1: keyword.control.conditional.if # keyword.control.conditional.if
          2: keyword.control.conditional.unless # keyword.control.conditional.unless
        set:
        - include: -tag-block-guts-

      - match: \b(?:(each)|(each-in)|(with))(?=\s)
        captures:
          1: keyword.control.conditional.each.handlebars
          2: keyword.control.conditional.each-in.handlebars
          3: keyword.control.conditional.with.handlebars
        set:
        # - meta_scope: default.handlebars
        # - include: -named-parameter-
        - include: -tag-block-guts-

      - match: ({{IDENTIFIER}}(?:\s*[./]{{IDENTIFIER}})*) # TODO: match individual parts
        scope: entity.name.function.helper # variable.function.handlebars
        set:
        # - meta_scope: default.handlebars
        - include: -tag-block-guts-

      - include: -tag-end-

  -tag-block-close-:
    - match: (?:{{TAG_BEGIN}})(/)
      captures:
        1: punctuation.definition.tag.template.begin.handlebars
        3: constant.character.block.close.handlebars
      push:

      - match: (?:(each)|(each-in)|(if)|(unless)|(with))(?=[{{TAG_END_CHAR}}])
        captures:
          1: keyword.control.loop.each.handlebars
          2: keyword.control.loop.each-in.handlebars
          3: keyword.control.conditional.if.handlebars
          4: keyword.control.conditional.unless.handlebars
          5: keyword.control.context.with.handlebars
        set:
        - include: -expect-tag-end-

      - match: ({{IDENTIFIER}}(?:\s*[./]{{IDENTIFIER}})*) # TODO: match individual parts
        scope: entity.name.function.helper.close.handlebars
        set:
        - include: -expect-tag-end-

      - include: -tag-end-

  -tag-block-guts-:
    - include: -tag-guts-
    # - include: -tag-end-
    # - include: -subexpression-
    # - include: -named-parameter-
    # - include: -key-value-
    # - include: -string-quoted-double-
    # - include: -string-quoted-single-
    # - include: -data-var-
    # - include: -path-
    # - include: -path-id-



  -else-:
    - match: \b(else)(?=[{{TAG_END_CHAR}}])
      scope: keyword.control.conditional.else.handlebars
      set:
      #- include: -tag-end-
      - include: -if-
      - include: -expect-tag-end-

  -if-:
    - match: \b(if)(?=[{{TAG_END_CHAR}}])
      scope: keyword.control.conditional.if.handlebars
      set:
      #- include: -expect-identifier-one-
      - include: -subexpression-end-
      - include: -subexpression-
      - include: -string-quoted-double-
      - include: -string-quoted-single-
      - include: -path-
      - include: -path-id-
      - match: ({{TAG_END}})
        scope: invalid.illegal.expected-condition.handlebars
        pop: true
      - match: ({{NOT_TAG_END}})
        scope: invalid.illegal.expected-condition.handlebars
        set:
        - include: -expect-tag-end-

  -key-value-:
    - match: ({{IDENTIFIER}})\s*(=) #\s*(?=['"]|{{IDENTIFIER_CHAR}})
      captures:
        1: meta.argument.key-value.key variable.parameter.helper
        2: punctuation.separator.key-value.handlebars
      push:
      - meta_scope: meta.argument.key-value.handlebars

      - include: -before-tag-end-pop-

      # Pop After String/Subexpression End
      - match: (?<=["')])
        pop: true

      # Subexpression
      - match: (?=\()
        push:
        - meta_scope: meta.argument.key-value.value.handlebars
        - include: -subexpression-
        - match: (?<=\))
          pop: true

      # String (Double Quotes)
      - match: (?=\s*")
        push:
        - meta_scope: meta.argument.key-value.value.handlebars
        - include: -string-quoted-double-
        - match: (?<=")
          pop: true

      # String (Single Quotes)
      - match: (?=\s*')
        push:
        - meta_scope: meta.argument.key-value.value.handlebars
        - include: -string-quoted-single-
        - match: (?<=')
          pop: true

      # Data Variable
      - match: (?=\s*@)
        push:
        - meta_scope: meta.argument.key-value.value.handlebars
        - include: -data-var-
        - match: (?=[){{TAG_END_CHAR}}])
          pop: true

      # Number
      - match: \s*{{NUMBER}}
        captures:
          1: meta.argument.key-value.value constant.numeric
        pop: true

      # Boolean
      - match: \s*{{BOOLEAN}}
        captures:
          1: meta.argument.key-value.value constant.language.boolean.true
          2: meta.argument.key-value.value constant.language.boolean.false
        pop: true

      # Identifier
      - match: \s*(?={{IDENTIFIER_CHAR}})
        set:
        - meta_scope: meta.argument.key-value meta.argument.key-value.value.handlebars
        - match: (?={{NON_IDENTIFIER_CHAR}})
          pop: true
        - include: -identifier-

      # Path
      - match: (?=\s*\.)
        push:
        - meta_scope: meta.argument.key-value.value.handlebars
        - match: (?=\s*\.)
          push:
          - include: -path-
        - match: (?<=\S)
          pop: true

      - include: -before-tag-end-pop-

  -named-parameter-:
    - match: \bas(?=\s)
      scope: keyword.control.operator.as.handlebars
      push:
      - match: (?<=\|)
        pop: true

      - include: -after-tag-end-pop-

      - match: (?:[^|{{TAG_END_CHAR}}]+)
        scope: invalid.illegal.expected-named-parameter-pipe.handlebars
        pop: true

      - match: \|
        scope: keyword.operator.assignment.named-parameter.handlebars
        push:
        - meta_scope: meta.named-parameter.handlebars
        - match: \|
          scope: keyword.operator.assignment.named-parameter.handlebars
          pop: true
        - match: ({{TAG_END}})
          scope: invalid.illegal.expected-named-parameter-pipe.handlebars
          pop: true
        - match: ({{IDENTIFIER}})
          scope: variable.other.readwrite.named-parameter.handlebars



  -path-:
    # Dot(s)
    - match: \.\.?(?={{LOOKAHEAD}})
      scope: meta.path-traversal -path-.handlebars
      set:
      #- meta_content_scope: meta.path-traversal -path--after-.handlebars
      - meta_content_scope: -path--after-.handlebars

      # Subsequent Slash
      - include: -path-slash-

      # Anything Except Slash
      - match: (?=\s*\S)
        set:
        - include: -before-tag-end-pop-
        - include: -tag-guts-

  -path-pop-:
    # Dot(s)
    - match: \.\.?(?={{LOOKAHEAD}})
      scope: meta.path-traversal -path-.handlebars
      set:
      - meta_content_scope: meta.path-traversal -path--after-.handlebars

      # Subsequent Slash
      - include: -path-slash-

      # Anything Except Slash
      - match: (?=\s*\S)
        pop: true

  -path-slash-:
    #- include: -before-tag-end-pop-

    # Slash
    - match: \s*/
      scope: meta.path-traversal -path-slash-.handlebars
      set:
      - meta_content_scope: meta.path-traversal -path-slash-.handlebars
      - include: -before-tag-end-pop-

      # Dot Followed By Not Dot
      - match: (\s*)(\.[^./{{TAG_END_CHAR}}])
        captures:
          1: meta.path-traversal.handlebars
          2: invalid.illegal.invalid-path.handlebars
        set:
        - include: -tag-guts-

      # Dots (Again)
      - match: \s*(?=\.\.?)
        scope: meta.path-traversal # bridge the gap between `/` and `.`.handlebars
        set: -path-

      # Identifiers
      - match: \s*(?=\[|{{IDENTIFIER_CHAR}})
        set:
        - include: -before-tag-end-pop-
        - include: -tag-guts-

      # Data Vars
      - match: \s*(?=@)
        set:
        - include: -data-var-

      # BAD Subsequent Slash
      - match: \s*/
        scope: invalid.illegal.invalid-path -path-slash-.handlebars
        pop: true

      # BAD Tag End
      - match: \s*({{TAG_END}})
        captures:
          1: invalid.illegal.expected-context-path -path-slash-
        pop: true

      # BAD Anything else
      - match: \S
        scope: invalid.illegal.invalid-path-character -path-slash-.handlebars
        pop: true

  -path-id-:
    # POP if we just passed a close tag.
    - include: -after-tag-end-pop-
    - include: -before-tag-end-pop-

    - match: this(?={{SEPARATOR}})
      scope: variable.language.this -path-id--this-.handlebars
      push:
      - meta_content_scope: -path-id--this-.handlebars
      - include: -path-id-after-

    - match: (?=-?\d+(\.\d+)?)
      push:
      - meta_scope: variable.parameter.helper.handlebars
      - include: -number-
      - match: (?=\D)
        pop: true

    - match: (?=true|false)
      push:
      - meta_scope: variable.parameter.helper.handlebars
      - include: -boolean-
      - match: (?=\W)
        pop: true

    - match: ({{IDENTIFIER}})(?={{SEPARATOR}})
      scope: variable.other.readwrite.path -path-id--id-.handlebars
      push:
      - meta_content_scope: -path-id--id--after- #bright.red-orange -path-id--id-.handlebars
      - include: -before-tag-end-pop-
      - match: (?=\s*\.this)
        pop: true
      - include: -path-id-after-

    - match: \[
      push:
      - meta_scope: variable.other.readwrite.path -path-id--bracketed-.handlebars
      - match: \]
        set:
        - meta_content_scope: -path-id--bracketed--after-.handlebars
        - include: -path-id-after-

    - match: ({{IDENTIFIER}}{{NOT_IDENTIFIER_NOT_SEPARATOR}}+[^{{TAG_END_CHAR}}]*)
      scope: invalid.illegal.invalid-path -path-id-.handlebars

    - match: ({{NOT_IDENTIFIER_NOT_SPACE}}+[^{{TAG_END_CHAR}}]*)
      scope: invalid.illegal.invalid-path -path-id-.handlebars

  -path-id-after-:
    # POP if we just passed a close tag.
    - include: -after-tag-end-pop-
    - include: -before-tag-end-pop-

    # Subsequent Dotted Identifier
    - match: \s*\.{{IDENTIFIER}}
      scope: variable.other.readwrite.path -path-id-after--dotted-.handlebars

    # Subsequent Dotted Bracketed Identifier
    - match: \s*\.\[
      push:
      # TODO: Fix double vars here.
      - meta_scope: meta.path.segment-literal variable.other.readwrite.path -path-id-after--bracketed-.handlebars
      - meta_content_scope: variable.other.readwrite.path.path-literal -path-id-after--bracketed-.handlebars
      - include: -number-
      - match: \]
        pop: true

    # Subsequent Quoted Identifier
    - match: \s*\.(')
      captures:
        1: string.quoted.single punctuation.definition.string.quoted.single
      push:
      # TODO: Fix double vars here.
      - meta_scope: meta.path.segment-literal variable.other.readwrite.path -path-id-after--bracketed-.handlebars
      - meta_content_scope: variable.other.readwrite.path.path-literal string.quoted.single -path-id-after--bracketed-.handlebars
      - include: -number-
      - match: \'
        scope: string.quoted.single punctuation.definition.string.quoted.single.handlebars
        pop: true

    # Subsequent Quoted Identifier
    - match: \s*\.(")
      captures:
        1: string.quoted.double punctuation.definition.string.quoted.double
      push:
      # TODO: Fix double vars here.
      - meta_scope: meta.path.segment-literal  variable.other.readwrite.path -path-id-after--bracketed-.handlebars
      - meta_content_scope: variable.other.readwrite.path.path-literal variable.other.readwrite.path.path-literal string.quoted.double -path-id-after--bracketed-.handlebars
      - include: -number-
      - match: \"
        scope: string.quoted.double punctuation.definition.string.quoted.double.handlebars
        pop: true

    # Subsequent Slash
    - match: \s*/
      set:
      - meta_scope: meta.path-traversal -path-id-after--separator-.handlebars

      # POP if we just passed a close tag.
      - include: -after-tag-end-pop-

      # Dots
      - match: \s*(?=\.\.?{{LOOKAHEAD}})
        pop: true

      # Identifiers
      - match: \s*(?=\[|{{IDENTIFIER_CHAR}})
        pop: true

      # BAD Subsequent Slash
      - match: \s*/
        scope: invalid.illegal.invalid-path -path-id-after--separator-.handlebars
        pop: true

      # BAD Tag End
      - match: \s*({{TAG_END}})
        captures:
          1: invalid.illegal.expected-context-path -path-id-after--separator-

      - match: (?=\s*\S)
        pop: true

    - include: -before-unmatched-char-pop-



  -this-:
    - match: \s*(this)
      set:
      - meta_content_scope: meta.path-traversal.handlebars

      - include: -slash-

      - match: \s*\.this

      - match: \s*\.(?=\[|{{IDENTIFIER_CHAR}})
        scope: variable.other.readwrite -this-.handlebars

      - include: -identifier-

      # Bad Dot
      - match: \s*(?=\.\.?[/{{TAG_END_CHAR}}])
        set:
        - include: -expect-tag-end-

      - match: ''
        pop: true

  -slash-:
    - match: \s*(/)
      set:
      - meta_content_scope: meta.path-traversal.handlebars

      - include: -this-
      - include: -dot-

      - match: ''
        pop: true

  -dot-:
    - match: \s*(\.\.?)(?=[/{{TAG_END_CHAR}}])
      set:
      - meta_content_scope: meta.path-traversal.handlebars

      - include: -slash-

      - match: ''
        pop: true

  -id-:
    - match: \[
      push:
      - meta_scope: bright.bluebird.handlebars
      - match: \]
        pop: true

    - match: (?={{IDENTIFIER_CHAR}}|\.\.?{{LOOKAHEAD}})
      push:
      - meta_scope: bright.bluebird.handlebars

      - match: (?=\s*\.this\b)
        set:
        - match: \.this
          scope: invalid.handlebars
          pop: true

      - match: (?=\s*/)
        set:
        - meta_scope: bright.orange.handlebars
        - match: \s*/
        - match: \s*({{NON_IDENTIFIER_CHAR}}\S*)
          scope: invalid.illegal.handlebars
          pop: true
        - match: (?=\S)
          pop: true

      - match: (?=\s*{{IDENTIFIER_CHAR}})
        pop: true

      - match: \s*\.{{IDENTIFIER}}

      - match: \s*\.\[
        push:
        - match: \]
          pop: true

      - include: -non-id-pop-

  -non-id-pop-:
    - match: (?=\s*{{NOT_IDENTIFIER_NOT_SPACE}})
      pop: true
    # - match: (?=\s*({{IDENTIFIER_CHAR}}|{{SEPARATOR}}))
    #   pop: true

  -number-:
    - match: (-?)(\d+(\.\d+)?)
      scope: constant.numeric.handlebars

  -boolean-:
    - match: (true)|(false)
      captures:
        1: constant.language.boolean.true.handlebars
        2: constant.language.boolean.false.handlebars



  -identifier-:
    - include: -tag-end-

    - match: \s*

    - match: (?=\/)
      set:
      - meta_content_scope: invalid.illegal.invalid-path.handlebars
      - include: -tag-end-

    - match: \s*\.\.?(?={{LOOKAHEAD}})
      push:
      - meta_scope: meta.path-traversal.handlebars
      - include: -before-tag-end-pop-
      - match: \s*(?={{IDENTIFIER_CHAR}})
        pop: true

    # - match: (?=this)
    #   push:
    #   # Match any identifiers.
    #   - match: (this)(?={{NON_IDENTIFIER_CHAR}})
    #     scope: variable.language.handlebars
    #     set:
    #     - meta_scope: -identifier--this variable.other.readwrite.handlebars
    #     - match: \s*/\s*(?=\.{{SEPARATOR}})
    #       scope: meta.path-traversal.handlebars
    #       pop: true
    #     - match: \s*/\s*(?=this)
    #       scope: meta.path-traversal.handlebars
    #       pop: true
    #     - match: \s*/\s*(?={{IDENTIFIER}})
    #       scope: meta.path-traversal.handlebars
    #       pop: true
    #     - match: \s*/\s*(?=\..)
    #       scope: meta.path-traversal.handlebars
    #       set:
    #       - include: -expect-tag-end-
    #     - match: \s*/
    #       scope: -identifier--this--after meta.path-traversal.handlebars
    #       set:
    #       # We should never reach an end tag here.
    #       - match: ({{TAG_END}})
    #         scope: invalid.illegal.expected-context-path.handlebars
    #         pop: true
    #     - include: -after-identifier-
    #   # If nothing matched, pop.
    #   - match: ''
    #     pop: true

    # - match: (?={{IDENTIFIER_CHAR}})
    #   push:
    #   # Match any identifiers.
    #   - match: ({{IDENTIFIER}})
    #     push:
    #     - meta_scope: -identifier--identifier variable.other.readwrite.handlebars
    #     - include: -after-identifier-
    #   # If nothing matched, pop.
    #   - match: ''
    #     pop: true

    # - match: \[
    #   push:
    #   - meta_scope: -identifier--bracketed variable.other.readwrite.handlebars
    #   - match: \]
    #     set:
    #     - meta_scope: variable.other.readwrite.handlebars
    #     - include: -after-identifier-

    - match: this(?={{SEPARATOR}})
      scope: variable.language.this -path-id--this-.handlebars
      push:
      - meta_content_scope: -path-id--this-.handlebars
      - include: -path-id-after-

    - match: ({{IDENTIFIER}})(?={{SEPARATOR}})
      scope: variable.other.readwrite.path -path-id--id-.handlebars
      push:
      - meta_content_scope: -path-id--id--after- #bright.red-orange -path-id--id-.handlebars
      - include: -before-tag-end-pop-
      - match: (?=\s*\.this)
        pop: true
      - include: -path-id-after-

    - match: \[
      push:
      - meta_scope: variable.other.readwrite.path -path-id--bracketed-.handlebars
      - match: \]
        set:
        - meta_content_scope: -path-id--bracketed--after-.handlebars
        - include: -path-id-after-

    - match: ({{IDENTIFIER}}{{NOT_IDENTIFIER_NOT_SEPARATOR}}+[^{{TAG_END_CHAR}}]*)
      scope: invalid.illegal.invalid-path -path-id-.handlebars

    - match: ({{NOT_IDENTIFIER_NOT_SPACE}}+[^{{TAG_END_CHAR}}]*)
      scope: invalid.illegal.invalid-path -path-id-.handlebars

  -after-identifier-:
    # Separator slashes
    - match: \s*/
      push:
      - meta_scope: -after-identifier--after-slash.handlebars
      # Identifier
      - match: \s*{{IDENTIFIER}}
        pop: true
      # Bracketed Identifier
      - match: \s*\[
        push:
        - match: \]
          pop: true
      - include: -after-identifier-

    # Subsequent Dotted Identifier
    - match: \s*\.{{IDENTIFIER}}
      push:
      - meta_scope: -after-identifier--after-dotted.handlebars
      - include: -after-identifier-

    # Subsequent Dotted, Bracketed Identifier
    - match: \s*\.\[
      push:
      - meta_scope: -after-identifier--bracketed.handlebars
      - match: \]
        pop: true

    # Subsequent Dotted Anything Else
    - match: (?=\s*\..|\s*\.$)
      set:
      - include: -expect-tag-end-

    - match: \s$

    # Upon reaching a non-identifier character, pop.
    - match: (?=\s*({{IDENTIFIER_CHAR}}|{{SEPARATOR}}))
      pop: true



  -subexpression-:
    - match: (\()[^)}~]*({{TAG_END}})
      captures:
        1: punctuation.definition.subexpression.begin.handlebars
        2: invalid.illegal.expected-close-paren.handlebars

    - match: \(
      scope: punctuation.definition.subexpression.begin.handlebars
      push:
      - meta_scope: meta.subexpression.handlebars
      - match: ({{IDENTIFIER}}(?:\s*[./]{{IDENTIFIER}})*) # TODO: match individual parts
        scope: entity.name.function.helper # variable.function.handlebars
        push:
        - include: -before-tag-end-pop-
        - include: -subexpression-end-
        #- include: -named-parameter- # I don’t think this is valid
        - include: -subexpression- # nested subexpressions
        - include: -key-value-
        - include: -string-quoted-double-
        - include: -string-quoted-single-
        - include: -data-var-
        - include: -path-
        - include: -path-id-
      - include: -subexpression-end-
  -subexpression-end-:
    - match: \)
      scope: punctuation.definition.subexpression.end.handlebars
      pop: true



  -identifier-one-:
    - match: ({{IDENTIFIER}})
      scope: variable.other.readwrite -identifier-one-.handlebars
      set:
      # Dotted paths named `this` are not allowed.
      - include: -unexpected-dotted-path-named-this-
      - include: -unexpected-identifier-

      # Subsequent identifiers immediately preceeded by a dot are allowed.
      - include: -identifier-one-dotted-
      - include: -identifier-path-literal-dotted-
      # Slashes are valid separators so go back to considering this a path.
      - include: -separator-slash-
      - include: -expect-tag-end-
    - match: \@
      scope: bright.bluebird.handlebars
    - include: -identifier-path-literal-
  -identifier-one-dotted-:
    - match: (\.{{IDENTIFIER}})
      scope: variable.other.readwrite -identifier-one-dotted-.handlebars
      set:
      # Subsequent identifiers immediately preceeded by a dot are allowed.
      - include: -identifier-one-dotted-
      - include: -identifier-path-literal-dotted-
      # Slashes are valid separators so go back to considering this a path.
      - include: -separator-slash-
      - include: -expect-tag-end-
  -before-identifier-one-pop-:
    - match: ({{IDENTIFIER}})
      scope: variable.other.readwrite -identifier-one-.handlebars
      set:
      # Dotted paths named `this` are not allowed.
      - include: -unexpected-dotted-path-named-this-
      - include: -unexpected-identifier-

      # Subsequent identifiers immediately preceeded by a dot are allowed.
      - include: -identifier-one-dotted-
      - include: -identifier-path-literal-dotted-
      # Slashes are valid separators so go back to considering this a path.
      - include: -separator-slash-
      #- include: -before-tag-end-pop-
    - match: \@
      scope: bright.bluebird.handlebars
    - include: -identifier-path-literal-

  -identifier-only-:
    - match: ({{IDENTIFIER}})
      scope: variable.other.readwrite -identifier-only-.handlebars
      set:
      # Dotted paths named `this` are not allowed.
      - include: -unexpected-dotted-path-named-this-

      # Subsequent identifiers immediately preceeded by a dot are allowed.
      - include: -identifier-only-dotted-
      - include: -identifier-path-literal-dotted-
      # Slashes are valid separators so go back to considering this a path.
      - include: -separator-slash-
      - include: -string-quoted-double-
      - include: -string-quoted-single-
      - include: -expect-tag-end-
    - include: -identifier-path-literal-
    - match: \@
      scope: bright.bluebird.handlebars
  -identifier-only-dotted-:
    - match: ((\.?){{IDENTIFIER}})
      scope: variable.other.readwrite -identifier-only-dotted-.handlebars
      # captures:
      #   2: punctuation.separator
      set:
      - include: -named-parameter-
      - include: -key-value-
      # Subsequent identifiers immediately preceeded by a dot are allowed.
      - include: -identifier-only-dotted-
      - include: -identifier-path-literal-dotted-
      # Slashes are valid separators so go back to considering this a path.
      - include: -separator-slash-
      - include: -string-quoted-double-
      - include: -string-quoted-single-
      - include: -expect-tag-end-

    #- include: -identifier-path-literal-dotted-

  -identifier-path-literal-:
    - match: \[
      scope: punctuation.definition.path.literal.end.handlebars
      set:
      - meta_scope: meta.path.literal -identifier-path-literal-.handlebars

      - match: (\d+)
        scope: constant.numeric.handlebars

      - match: ([^]]+)
        scope: variable.other.readwrite.handlebars

      - match: (])
        scope: punctuation.definition.path.literal.end.handlebars
        set:
        - include: -separator-slash-
        - include: -expect-tag-end-
  -identifier-path-literal-dotted-:
    - match: (\.)(\[)
      captures:
        1: variable.other.readwrite.handlebars
        2: punctuation.definition.path.literal.end.handlebars
      push:
      - meta_scope: meta.path.literal -identifier-path-literal-dotted-.handlebars

      - match: (\d+)
        scope: constant.numeric.handlebars

      - match: ([^]]+)
        scope: variable.other.readwrite.handlebars

      - match: (])
        scope: punctuation.definition.path.literal.end.handlebars
        pop: true



  -data-var-:
    # POP if we just passed a close tag.
    - include: -after-tag-end-pop-
    - include: -before-tag-end-pop-

    - match: (\@)(\s*)
      captures:
        1: constant.character.data-variable.handlebars
        2: meta.path-traversal.handlebars
      push:
      - meta_scope: variable.language.data -data-var- #-data-var--content-.handlebars

      - match: ^\s*

      # Identifier
      #- match: (?=\[|{{IDENTIFIER_CHAR}})
      - match: (?={{IDENTIFIER_CHAR}})
        push:
        - include: -data-var-path-id-

      # Path
      - include: -data-var-path-

      # POP Anything Else
      - include: -before-unmatched-char-pop-

  -data-var-path-:
    # POP if we just passed a close tag.
    - include: -after-tag-end-pop-
    - include: -before-tag-end-pop-
    #- include: -before-tag-end-pop-

    # Dot(s)
    - match: \.\.?(?={{LOOKAHEAD}})
      #scope: meta.path-traversal -data-var-path-.handlebars
      push:
      - meta_scope: meta.path-traversal -data-var-path--after-.handlebars
      #- include: -before-tag-end-pop-

      # Subsequent Slash
      - include: -data-var-path-slash-
      # - match: \s*/
      #   push:
      #   - meta_scope: bright.red-orange.handlebars
      #   - match: \s*/
      #     scope: invalid.illegal.handlebars
      #     pop: true
      #   - match: \s*\.\.?(?={{LOOKAHEAD}})
      #     scope: bright.yellow.handlebars
      #     pop: true
      #   - match: (?=\s*\S)
      #     pop: true

      # Anything Except Slash
      - match: (?=\s*\S)
        pop: true
        # set:
        # - include: -before-tag-end-pop-
        # - include: -tag-guts-

  -data-var-path-slash-:
    # Slash
    - match: \s*/
      scope: meta.path-traversal -data-var-path-slash-.handlebars
      set:
      - meta_content_scope: meta.path-traversal -data-var-path-slash--after-.handlebars

      # Dots (Again)
      - match: \s*(?=\.\.?)
        scope: meta.path-traversal -data-var-path-slash--dots- # bridge the gap between `/` and `.`.handlebars
        pop: true

      # Identifiers
      - match: \s*(?=\[|{{IDENTIFIER_CHAR}})
        set:
        - include: -data-var-path-id-

      # BAD Subsequent Slash
      - match: \s*/
        scope: invalid.illegal.invalid-path.handlebars
        pop: true

      # BAD Tag End
      - match: \s*({{TAG_END}})
        captures:
          1: invalid.illegal.expected-context-path.handlebars
        pop: true

      - include: -before-unmatched-char-pop-

  -data-var-path-id-:
    - include: -before-tag-end-pop-

    - match: (?:(first)|(index)|(key)|(last)|(partial-block)|(root)|(this))(?={{SEPARATOR}})
      captures:
        1: variable.language.data.keyword.first -data-var-path-id--keyword-
        2: variable.language.data.keyword.index -data-var-path-id--keyword-
        3: variable.language.data.keyword.key -data-var-path-id--keyword-
        4: variable.language.data.keyword.last -data-var-path-id--keyword-
        5: variable.language.data.keyword.partial-block -data-var-path-id--keyword-
        6: variable.language.data.keyword.root -data-var-path-id--keyword-
        7: variable.language.data.keyword.this -data-var-path-id--keyword-
      set:
      - meta_scope: -data-var-path-id--this--after-.handlebars
      # - match: (?=\s*\.((first)|(index)|(key)|(last)|(root)|(this)))
      - match: (?=\s*\.this)
        pop: true
      - include: -data-var-path-id-after-

    - match: ({{IDENTIFIER}})(?={{SEPARATOR}})
      scope: variable.other.readwrite.path -data-var-path-id--id-.handlebars
      set:
      - meta_scope: -data-var-path-id--id--after-.handlebars
      - include: -data-var-path-id-after-

    - match: \[
      set:
      - meta_scope: variable.other.readwrite.path -data-var-path-id--bracketed-.handlebars
      - match: \]
        set:
        - meta_scope: -data-var-path-id--id-bracketed--after-.handlebars
        - include: -data-var-path-id-after-

    - match: ({{IDENTIFIER}}{{NOT_IDENTIFIER_NOT_SEPARATOR}}+[^{{TAG_END_CHAR}}]*)
      scope: invalid.illegal.invalid-path -path-id-.handlebars

    - match: ({{NOT_IDENTIFIER_NOT_SPACE}}+[^{{TAG_END_CHAR}}]*)
      scope: invalid.illegal.invalid-path -path-id-.handlebars

  -data-var-path-id-after-:
    # POP if we just passed a close tag.
    - include: -after-tag-end-pop-
    - include: -before-tag-end-pop-

    # Subsequent Dotted Identifier
    - match: \s*\.{{IDENTIFIER}}
      scope: variable.other.readwrite.path -data-var-path-id-after--dotted-.handlebars

    # Subsequent Dotted Bracketed Identifier
    - match: \s*\.\[
      push:
      - meta_scope: variable.other.readwrite.path -data-var-path-id-after--bracketed-.handlebars
      - match: \]
        pop: true

    # Subsequent Slash
    - include: -data-var-path-slash-

    - include: -before-unmatched-char-pop-



  -string-quoted-double-:
    - match: (?<=[{\s=]|^)(")
      scope: punctuation.definition.string.quoted.double.handlebars
      push:
      - meta_scope: string.quoted.double.handlebars
      - include: -escape-char- #- include: -before-tag-end-pop-
      - match: (")
        scope: punctuation.definition.string.quoted.double.handlebars
        pop: true

  -string-quoted-single-:
    - match: (?<=[{\s=]|^)(')
      scope: punctuation.definition.string.quoted.single.handlebars
      push:
      - meta_scope: string.quoted.single.handlebars
      - include: -escape-char- #- include: -before-tag-end-pop-
      - match: (')
        scope: punctuation.definition.string.quoted.single.handlebars
        pop: true

  -string-quoted-single-one-:
    - match: (')
      scope: punctuation.definition.string.quoted.single.handlebars
      push:
      - meta_scope: string.quoted.single.handlebars
      - include: -escape-char- #- include: -before-tag-end-pop-
      - match: (')
        scope: punctuation.definition.string.quoted.single.handlebars
        set:
        - include: -expect-tag-end-

  -string-quoted-double-one-:
    - match: (")
      scope: punctuation.definition.string.quoted.double.handlebars
      push:
      - meta_scope: string.quoted.double.handlebars
      - include: -escape-char- #- include: -before-tag-end-pop-
      - match: (")
        scope: punctuation.definition.string.quoted.double.handlebars
        set:
        - include: -expect-tag-end-



  -expect-this-:
    - match: (\s*)\b(this)
      captures:
        1: meta.path-traversal.handlebars
        2: variable.language.this.handlebars
      set:
      - meta_content_scope: meta.path-traversal.handlebars

      # Unexpected `this`
      - match: (?=\s*this)
        set:
        - meta_content_scope: unexpected-this.handlebars
        - include: -expect-tag-end-

      # Special case for `.this` (continue looking for context path slashes and dots)
      - match: \s*\.(?=this)
        set:
        - include: -expect-this-

      # Unexpected dot
      - match: (?=\s*\.{{NON_IDENTIFIER_CHAR}})
        set:
        - meta_scope: unexpected-dot.handlebars
        - include: -expect-tag-end-

      - include: -expect-slash-
      - include: -expect-identifier-dotted-only-
      - include: -tag-end-

    - include: -tag-end-

  -expect-dot-:
    - match: \s*\.\.?(?=[/{{TAG_END_CHAR}}])
      scope: meta.path-traversal.handlebars
      set:
      - meta_content_scope: meta.path-traversal.handlebars


      - include: -unexpected-identifier-

      - include: -expect-slash-
      - include: -tag-end-

  -expect-slash-:
    - match: /
      set:
      - meta_content_scope: meta.path-traversal -expect-slash-.handlebars

      # Unexpected slash
      # - match: (?=\s*/)
      #   set:
      #   - meta_scope: unexpected-slash.handlebars
      #   - include: -expect-tag-end-

      # `this`
      - match: (?=\s*this) # Fixes double meta scope issue
        set:
        - include: -expect-this-

      # Identifier
      - match: (?=\s*(\[|{{IDENTIFIER}}))
        set:
        # - match: \s*
        - include: -identifier-one-

      # Dot(s)
      - match: (?=\s*\.\.?[/{{TAG_END_CHAR}}]) # Fixes double meta scope issue
        set:
        - include: -expect-dot-

      # Unexpected tag end
      - match: \s*({{TAG_END}})
        captures:
          1: invalid.illegal.expected-context-path.handlebars
        pop: true

      # Non-Identifier Char
      - match: (?=\s*{{NOT_IDENTIFIER_NOT_SPACE}})
        set:
        - include: -expect-tag-end-

      # Unexpected sub-path
      # - match: (?={{NON_IDENTIFIER_CHAR}})
      #   set:
      #   - meta_scope: unexpected-sub-path.handlebars
      #   # TODO: Make a separate one of these with the correct error message.
      #   - include: -expect-tag-end-

      # TODO: Make error message clearer
      # - include: -expect-tag-end-


  -separator-slash-:
    - match: (?=/[^!"#%&''()*+,./;<=>@\\\]^`{|}~])
      set:
      - meta_scope: meta.path-traversal # colors the slash itself.handlebars
      - include: -expect-slash-

  -escape-char-:
    - match: (\\.)
      scope: constant.character.escape.handlebars



  -tag-end-:
    - match: (?:\s*{{TAG_END}})
      captures:
        1: punctuation.definition.tag.template.end.handlebars
      # scope: bright.yellow.handlebars
      pop: true

  -before-tag-end-pop-:
    - match: (?=\s*{{TAG_END_PAREN}})
      pop: true

  -after-tag-end-pop-:
    - match: (?<=}})
      pop: true

  -before-unmatched-char-pop-:
    - match: \s*$
    - match: (?=\s*\S)
      pop: true


  -expect-tag-end-:
    - include: -before-tag-end-pop-
    #- include: -tag-end-
    - match: ({{NOT_TAG_END}})
      scope: invalid.illegal.expected-tag-end.handlebars
      set:
      - include: -expect-tag-end-

  -expect-identifier-one-:
    #- include: -path-
    - match: (?=['"]|{{IDENTIFIER}})
      set:
      - include: -identifier-one-
      - include: -string-quoted-single-one-
      - include: -string-quoted-double-one-
      - include: -tag-end-
      # push:
      # - include: -identifier-one-
      # - include: -string-quoted-single-one-
      # - include: -string-quoted-double-one-
      # - include: -tag-end-
      # - match: ({{NOT_TAG_END}})
      #   pop: true

  -expect-identifier-dotted-only-:
    - match: (?=\s*\.{{IDENTIFIER}})
      set:
      #- meta_scope: meta.identifier.handlebars

      # For subsequent `.foo` matches, determine if the dot is followed by a non-identifier char.
      - match: (?=\.{{NON_IDENTIFIER_CHAR}})
        set:
        - include: -expect-tag-end-

      # Slashes are valid separators so go back to considering this a path.
      - include: -separator-slash-

      # Only `.foo` or the tag end is allowed. Anything else is invalid.
      # Whenever any character that is not a dot, space or the tag end is matched, mark it -- and
      # anything following it -- as invalid (until the tag end).
      - match: (?=[^.{{TAG_END_CHAR}}])
        set:
        - meta_scope: invalid-identifier-character.handlebars
        - include: -expect-tag-end-

      # Dotted paths named `this` are not allowed.
      - include: -unexpected-dotted-path-named-this-

      # Match an identifier.
      - match: \.?{{IDENTIFIER}}
        scope: variable.other.readwrite -expect-identifier-dotted-only-.handlebars

      - include: -tag-end-


  -unexpected-identifier-:
    - match: (?={{IDENTIFIER}})
      set:
      - meta_scope: unexpected-identifier.handlebars
      - include: -expect-tag-end-

  -unexpected-dotted-path-named-this-:
    - match: \s*
    # Dotted paths named `this` are not allowed.
    - match: (?=\.?this)
      set:
      - meta_scope: paths-named-this-not-allowed.handlebars
      - include: -expect-tag-end-
